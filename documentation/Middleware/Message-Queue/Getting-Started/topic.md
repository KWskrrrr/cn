# 主题（Topic）
消息队列JCQ通过创建主题（topic）来对消息进行消息分类，Topic类型分为JCQ Topic 和 RocketMQ Topic。

消息类型：

* JCQ 类型的Topic支持普通消息与全局顺序消息，支持用户使用JCQ客户端接入；
* RocketMQ 类型的Topic支持普通消息、全局顺序消息、分区顺序消息和事务消息，支持用户使用RocketMQ客户端接入JCQ服务。

用户创建topic后Topic类型及消息类型不支持变更。

## 普通消息

普通消息是指消息队列JCQ中无特性的消息，在消息类型为普通消息的Topic中，可以发送延时消息。

普通消息Topic并不保证严格顺序，但在大多数场景下都是Partition级别的有序，这是因为单独的生产者写入同一个Partition是顺序的，单独的消费者从同一个Partition消费也是顺序的。但多个生产者、多个消费者之间并不能做这样的假设。

**应用场景**

适用于并发量大，对消息顺序无要求的场景，适用于广泛的消息通知，系统解耦等。


## 全局顺序消息
全局顺序消息（FIFO消息）是消息队列JCQ提供的一种严格按照顺序来发布和消费的消息。顺序发布和顺序消费是指对于指定的一个Topic，生产者按照一定的先后顺序发布消息；消费者按照既定的先后顺序订阅消息，即先发布的消息一定会先被客户端接收到。

顺序消息topic只有一个Partition，服务端保证JCQ收到消息的顺序，与用户消费的消息是一致的。不支持并发消费。

**应用场景**

适用于性能要求不高，所有的消息严格按照FIFO原则来发布和消费的场景。

在证券处理中，以人民币兑换美元为Topic，在价格相同的情况下，先出价者优先处理，则可以按照FIFO的方式发布和消费全局顺序消息。

## 延时消息

Producer成功发送一条消息到消息队列JCQ服务端后，这条消息并不会马上被消费者消费，而是在某个特定的时间或者延迟一段时间后，消息才被消费者可见并进行后续的消费，发送延时消息时需要设定一个延时时间长度，消息将从当前发送时间点开始延迟固定时间之后才开始投递。

延时消息需在消息类型为普通消息的Topic中发送；消息类型为全局顺序消息的Topic，不支持发送延时消息。


**应用场景**

消息生产和消费有时间窗口要求，例如各类线上活动，用户参与线上活动，完成一系列任务，活动时间之后，运营方发送系统通知或活动结果通知用户等。

广泛应用于信息提醒等比较通用的场景。通过消息触发一些定时任务，例如在某一固定时间点向用户发送提醒消息。

## 死信消息

死信队列⽤于处理⽆法被正常消费的消息。当⼀条消息初次消费失败，消息队列会⾃动进⾏消息重试；达到最⼤重试次数后，若消费依然失败，则表明消费者在正常情况下⽆法正确地消费该消息，此时，消息队列不会⽴刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。将这种正常情况下⽆法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。

注意：只有普通消息消费失败支持推送至死信队列，FIFO消息不支持死信队列。

**应用场景**

通过在死信队列中留出和隔离这些消息以确定其处理失败的原因，定位问题，区分消息类型(普通、顺序)，可按照Topic和ConsumerGroup ID进行搜索。例如：某条消息被多次消费后却未被删除，一般是由于该消息未被正确消费，可能存在问题需要回溯定位。

您可以设置最大接收次数，超额后该消息会被淘汰到指定的死信队列，便于后续问题发现。

对于死信可以选择全部重新发送或者全部删除。全部重新发送，死信将再次进入topic发送给这条订阅关系的订阅者；全部删除，死信将全部删除，不再发送。到达死信队列上限后，topic会暂停发送消息功能，待用户处理订阅者的异常。

## 分区顺序消息

对于Topic类型为RocketMQ主题的指定Topic，所有消息根据Sharding Key进行区块分区，同一个分区内的消息按照严格的先进先出（FIFO）原则进行发布和消费。同一分区内的消息保证顺序，不同分区之间的消息顺序不做要求。

**应用场景**

适用于性能要求高，以Sharding Key作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。

电商的订单创建，以订单ID作为Sharding Key，同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。以业务ID来保证具体某个ID的业务顺序,相对全局顺序消息提供了更好的性能。


## 事务消息

事务消息：Topic类型为RocketMQ的主题提供类似XA或Open XA的分布式事务功能，能达到分布式事务的最终一致。

半事务消息：暂不能投递的消息，生产者已经成功地将消息发送到了消息队列JCQ服务端，但是消费者未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半事务消息。

消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，消息队列JCQ服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit或是Rollback），该询问过程即消息回查。

事务消息交互流程如图：
 
事务消息发送步骤如下：

1.	生产者将半事务消息发送至消息队列JCQ服务端。

3.	消息队列JCQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息为半事务消息。

4.	生产者开始执行本地事务逻辑。

5.	生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：

二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。

二次确认结果为Rollback：服务端不会将该消息投递给消费者，并按照如下逻辑进行回查处理。

说明：系统默认的回查间隔，间隔5s，15次回查。

**应用场景**

分布式事务消息适用于所有对数据最终一致性有强需求的场景。

在京东购物车下单时，涉及到购物车系统和交易系统，这两个系统之间的数据最终一致性可以通过分布式事务消息的异步处理实现。在这种场景下，交易系统是最为核心的系统，需要最大限度地保证下单成功。而购物车系统只需要订阅消息队列的交易订单消息，做相应的业务处理，即可保证最终的数据一致性。

